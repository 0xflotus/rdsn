The following figure shows the architecture of rDSN, which follows the idea of "microkernel" so that most of the components can be customized and plugged in. The kernel of rDSN is the "Core" part, which maps the **Service API** to the **Tool API** around an even-driven architecture. Developers can write applications and plugins using these APIs, and the current rDSN already contains many examples there, including programming agility libraries, distributed system frameworks (e.g., replication), various system runtime libraries (e.g., network, file aio, lock), testing and debugging tools, admission control policies, among a few others. 

![rDSN's Architecture](https://raw.githubusercontent.com/wiki/imzhenyu/rDSN/images/arch.png)

The service API contains five categories, including all the necessary non-deterministic APIs for implementing a back-end network application, such as APIs related to even-driven (tasking), thread synchronization, RPC, file operation, as well as non-deterministic environment input (time and random). It is required that all non-deterministic behaviors of the applications must go through the service API so the later plug-ins can work. It is also therefore safe for applications to call any deterministic functions.

The tool API exposes all the non-determinisms to the plug-ins, in the form of component providers, join points and state extensions. The core in rDSN usually does not implement concrete runtime features but only define the interface, such as what should a network interface, or a reader-writer lock should be. Developers implement what they want and plug them into the framework, called component providers. Join points allow hooks at **all** asynchronous transition points where the event (or task) flows in the system, so that developers can monitor, or taint analyze, or even manipulate what happens there. State extension provides appended state to some common abstract in the system, such as adding timestamps to an event/task. The three mechanisms together, is a powerful combination to implement many useful tools; see our examples in code for details.

