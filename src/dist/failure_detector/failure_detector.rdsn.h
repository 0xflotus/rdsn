/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef failure_detector_rDSN_H
#define failure_detector_rDSN_H

#include "fd_types.h"
#include <dsn/serverlet.h>
#include <iostream>

namespace dsn { namespace fd {


// define task code for svc 'failure_detector'
DEFINE_NAMED_TASK_CODE_RPC(RPC_FAILURE_DETECTOR_PING, ping, ::dsn::TASK_PRIORITY_COMMON, THREAD_POOL_FD_DEFAULT)
DEFINE_TASK_CODE(LPC_FAILURE_DETECTOR_CIENT_TEST_TIMER, ::dsn::TASK_PRIORITY_COMMON, THREAD_POOL_FD_DEFAULT)


// server
template <typename T> // where T : failure_detector_service<T>
class failure_detector_service 
	: public ::dsn::service::serverlet<T>
{
public:
	failure_detector_service() : ::dsn::service::serverlet<T>("failure_detector") {}
	virtual ~failure_detector_service() {}

protected:
	// all service handlers to be implemented further
	// RPC_FAILURE_DETECTOR_PING
	virtual void ping(const beacon_msg& beacon, ::dsn::service::rpc_replier<beacon_ack>& reply) = 0;

public:
	void open_service()
	{
		this->register_async_rpc_handler(RPC_FAILURE_DETECTOR_PING, "ping", &T::ping);
	}

	void close_service()
	{
		this->unregister_rpc_handler(RPC_FAILURE_DETECTOR_PING);
	}
};


// sync client
class failure_detector_client
{
public:
	static ::dsn::error_code ping(
		const ::dsn::end_point& server, 
		beacon_msg& beacon, 
		__out_param beacon_ack& resp, 
		int timeout_milliseconds = 0, 
		int hash = 0)
	{
		::dsn::message_ptr msg = ::dsn::message::create_request(RPC_FAILURE_DETECTOR_PING, timeout_milliseconds, hash);
		marshall(msg->writer(), beacon);
		auto resp_task = ::dsn::service::rpc::call(server, msg, nullptr);
		resp_task->wait();
		if (resp_task->error() == ::dsn::ERR_SUCCESS)
		{
			unmarshall(resp_task->get_response()->reader(), resp);
		}
		return resp_task->error();
	}

};


// async client
class failure_detector_async_client 
	: public virtual ::dsn::service::servicelet
{
public:

	::dsn::rpc_response_task_ptr begin_ping(
		const ::dsn::end_point& server, 
		std::shared_ptr<beacon_msg>& beacon, 
		int request_hash = 0, 
		int timeout_milliseconds = 0, 
		int reply_hash = 0)
	{
		return ::dsn::service::rpc::call_typed(server, RPC_FAILURE_DETECTOR_PING, beacon, this, &failure_detector_async_client::end_ping, request_hash, timeout_milliseconds, reply_hash);
	}

	virtual void end_ping(
		::dsn::error_code err, 
		std::shared_ptr<beacon_msg> req, 
		std::shared_ptr<beacon_ack> resp)
	{
		if (err != ::dsn::ERR_SUCCESS) std::cout << "reply err : " << err.to_string() << std::endl;
		else
		{
			std::cout << "reply ok" << std::endl;
		}
	}

};


}} // namespace


#endif
