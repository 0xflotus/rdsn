/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef fd_TYPES_H
#define fd_TYPES_H

# include <dsn/internal/serialization.h>

DEFINE_THREAD_POOL_CODE(THREAD_POOL_FD_DEFAULT)

namespace dsn { namespace fd {

class beacon_msg;

class beacon_ack;


class beacon_msg {
 public:

  beacon_msg(const beacon_msg&);
  beacon_msg& operator=(const beacon_msg&);
  beacon_msg() : time(0) {
  }

  virtual ~beacon_msg() throw();
  int64_t time;
   ::dsn::end_point from;
   ::dsn::end_point to;
  bool operator == (const beacon_msg & rhs) const
  {
    if (!(time == rhs.time))
      return false;
    if (!(from == rhs.from))
      return false;
    if (!(to == rhs.to))
      return false;
    return true;
  }
  bool operator != (const beacon_msg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const beacon_msg & ) const;


};

void swap(beacon_msg &a, beacon_msg &b);

inline void unmarshall(::dsn::utils::binary_reader& reader, __out_param beacon_msg& val) {
  ::dsn::utils::unmarshall(reader, val.time);
  unmarshall(reader, val.from);
  unmarshall(reader, val.to);
}

inline void marshall(::dsn::utils::binary_writer& writer, const beacon_msg& val, uint16_t pos = 0xffff) {
  ::dsn::utils::marshall(writer, val.time, pos);
  marshall(writer, val.from, pos);
  marshall(writer, val.to, pos);
}


class beacon_ack {
 public:

  beacon_ack(const beacon_ack&);
  beacon_ack& operator=(const beacon_ack&);
  beacon_ack() : time(0), is_master(0), allowed(0) {
  }

  virtual ~beacon_ack() throw();
  int64_t time;
  bool is_master;
   ::dsn::end_point primary_node;
  bool allowed;
  bool operator == (const beacon_ack & rhs) const
  {
    if (!(time == rhs.time))
      return false;
    if (!(is_master == rhs.is_master))
      return false;
    if (!(primary_node == rhs.primary_node))
      return false;
    if (!(allowed == rhs.allowed))
      return false;
    return true;
  }
  bool operator != (const beacon_ack &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const beacon_ack & ) const;


};

void swap(beacon_ack &a, beacon_ack &b);

inline void unmarshall(::dsn::utils::binary_reader& reader, __out_param beacon_ack& val) {
  ::dsn::utils::unmarshall(reader, val.time);
  ::dsn::utils::unmarshall(reader, val.is_master);
  unmarshall(reader, val.primary_node);
  ::dsn::utils::unmarshall(reader, val.allowed);
}

inline void marshall(::dsn::utils::binary_writer& writer, const beacon_ack& val, uint16_t pos = 0xffff) {
  ::dsn::utils::marshall(writer, val.time, pos);
  ::dsn::utils::marshall(writer, val.is_master, pos);
  marshall(writer, val.primary_node, pos);
  ::dsn::utils::marshall(writer, val.allowed, pos);
}

}} // namespace

#endif
