/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "idl_test_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn {
namespace idl {
namespace test {

test_thrift_item::~test_thrift_item() throw() {}

void test_thrift_item::__set_bool_item(const bool val) { this->bool_item = val; }

void test_thrift_item::__set_byte_item(const int8_t val) { this->byte_item = val; }

void test_thrift_item::__set_i16_item(const int16_t val) { this->i16_item = val; }

void test_thrift_item::__set_i32_item(const int32_t val) { this->i32_item = val; }

void test_thrift_item::__set_i64_item(const int64_t val) { this->i64_item = val; }

void test_thrift_item::__set_double_item(const double val) { this->double_item = val; }

void test_thrift_item::__set_string_item(const std::string &val) { this->string_item = val; }

void test_thrift_item::__set_list_i32_item(const std::vector<int32_t> &val)
{
    this->list_i32_item = val;
}

void test_thrift_item::__set_set_i32_item(const std::set<int32_t> &val)
{
    this->set_i32_item = val;
}

void test_thrift_item::__set_map_i32_item(const std::map<int32_t, int32_t> &val)
{
    this->map_i32_item = val;
}

uint32_t test_thrift_item::read(::apache::thrift::protocol::TProtocol *iprot)
{

    apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ::apache::thrift::protocol::T_STOP) {
            break;
        }
        switch (fid) {
        case 1:
            if (ftype == ::apache::thrift::protocol::T_BOOL) {
                xfer += iprot->readBool(this->bool_item);
                this->__isset.bool_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 2:
            if (ftype == ::apache::thrift::protocol::T_BYTE) {
                xfer += iprot->readByte(this->byte_item);
                this->__isset.byte_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 3:
            if (ftype == ::apache::thrift::protocol::T_I16) {
                xfer += iprot->readI16(this->i16_item);
                this->__isset.i16_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 4:
            if (ftype == ::apache::thrift::protocol::T_I32) {
                xfer += iprot->readI32(this->i32_item);
                this->__isset.i32_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 5:
            if (ftype == ::apache::thrift::protocol::T_I64) {
                xfer += iprot->readI64(this->i64_item);
                this->__isset.i64_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 6:
            if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                xfer += iprot->readDouble(this->double_item);
                this->__isset.double_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 7:
            if (ftype == ::apache::thrift::protocol::T_STRING) {
                xfer += iprot->readString(this->string_item);
                this->__isset.string_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 8:
            if (ftype == ::apache::thrift::protocol::T_LIST) {
                {
                    this->list_i32_item.clear();
                    uint32_t _size0;
                    ::apache::thrift::protocol::TType _etype3;
                    xfer += iprot->readListBegin(_etype3, _size0);
                    this->list_i32_item.resize(_size0);
                    uint32_t _i4;
                    for (_i4 = 0; _i4 < _size0; ++_i4) {
                        xfer += iprot->readI32(this->list_i32_item[_i4]);
                    }
                    xfer += iprot->readListEnd();
                }
                this->__isset.list_i32_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 9:
            if (ftype == ::apache::thrift::protocol::T_SET) {
                {
                    this->set_i32_item.clear();
                    uint32_t _size5;
                    ::apache::thrift::protocol::TType _etype8;
                    xfer += iprot->readSetBegin(_etype8, _size5);
                    uint32_t _i9;
                    for (_i9 = 0; _i9 < _size5; ++_i9) {
                        int32_t _elem10;
                        xfer += iprot->readI32(_elem10);
                        this->set_i32_item.insert(_elem10);
                    }
                    xfer += iprot->readSetEnd();
                }
                this->__isset.set_i32_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        case 10:
            if (ftype == ::apache::thrift::protocol::T_MAP) {
                {
                    this->map_i32_item.clear();
                    uint32_t _size11;
                    ::apache::thrift::protocol::TType _ktype12;
                    ::apache::thrift::protocol::TType _vtype13;
                    xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
                    uint32_t _i15;
                    for (_i15 = 0; _i15 < _size11; ++_i15) {
                        int32_t _key16;
                        xfer += iprot->readI32(_key16);
                        int32_t &_val17 = this->map_i32_item[_key16];
                        xfer += iprot->readI32(_val17);
                    }
                    xfer += iprot->readMapEnd();
                }
                this->__isset.map_i32_item = true;
            } else {
                xfer += iprot->skip(ftype);
            }
            break;
        default:
            xfer += iprot->skip(ftype);
            break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t test_thrift_item::write(::apache::thrift::protocol::TProtocol *oprot) const
{
    uint32_t xfer = 0;
    apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("test_thrift_item");

    xfer += oprot->writeFieldBegin("bool_item", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->bool_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("byte_item", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->byte_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("i16_item", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->i16_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("i32_item", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->i32_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("i64_item", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->i64_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("double_item", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->double_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("string_item", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->string_item);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("list_i32_item", ::apache::thrift::protocol::T_LIST, 8);
    {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                      static_cast<uint32_t>(this->list_i32_item.size()));
        std::vector<int32_t>::const_iterator _iter18;
        for (_iter18 = this->list_i32_item.begin(); _iter18 != this->list_i32_item.end();
             ++_iter18) {
            xfer += oprot->writeI32((*_iter18));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("set_i32_item", ::apache::thrift::protocol::T_SET, 9);
    {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32,
                                     static_cast<uint32_t>(this->set_i32_item.size()));
        std::set<int32_t>::const_iterator _iter19;
        for (_iter19 = this->set_i32_item.begin(); _iter19 != this->set_i32_item.end(); ++_iter19) {
            xfer += oprot->writeI32((*_iter19));
        }
        xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("map_i32_item", ::apache::thrift::protocol::T_MAP, 10);
    {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32,
                                     ::apache::thrift::protocol::T_I32,
                                     static_cast<uint32_t>(this->map_i32_item.size()));
        std::map<int32_t, int32_t>::const_iterator _iter20;
        for (_iter20 = this->map_i32_item.begin(); _iter20 != this->map_i32_item.end(); ++_iter20) {
            xfer += oprot->writeI32(_iter20->first);
            xfer += oprot->writeI32(_iter20->second);
        }
        xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(test_thrift_item &a, test_thrift_item &b)
{
    using ::std::swap;
    swap(a.bool_item, b.bool_item);
    swap(a.byte_item, b.byte_item);
    swap(a.i16_item, b.i16_item);
    swap(a.i32_item, b.i32_item);
    swap(a.i64_item, b.i64_item);
    swap(a.double_item, b.double_item);
    swap(a.string_item, b.string_item);
    swap(a.list_i32_item, b.list_i32_item);
    swap(a.set_i32_item, b.set_i32_item);
    swap(a.map_i32_item, b.map_i32_item);
    swap(a.__isset, b.__isset);
}

test_thrift_item::test_thrift_item(const test_thrift_item &other21)
{
    bool_item = other21.bool_item;
    byte_item = other21.byte_item;
    i16_item = other21.i16_item;
    i32_item = other21.i32_item;
    i64_item = other21.i64_item;
    double_item = other21.double_item;
    string_item = other21.string_item;
    list_i32_item = other21.list_i32_item;
    set_i32_item = other21.set_i32_item;
    map_i32_item = other21.map_i32_item;
    __isset = other21.__isset;
}
test_thrift_item &test_thrift_item::operator=(const test_thrift_item &other22)
{
    bool_item = other22.bool_item;
    byte_item = other22.byte_item;
    i16_item = other22.i16_item;
    i32_item = other22.i32_item;
    i64_item = other22.i64_item;
    double_item = other22.double_item;
    string_item = other22.string_item;
    list_i32_item = other22.list_i32_item;
    set_i32_item = other22.set_i32_item;
    map_i32_item = other22.map_i32_item;
    __isset = other22.__isset;
    return *this;
}
void test_thrift_item::printTo(std::ostream &out) const
{
    using ::apache::thrift::to_string;
    out << "test_thrift_item(";
    out << "bool_item=" << to_string(bool_item);
    out << ", "
        << "byte_item=" << to_string(byte_item);
    out << ", "
        << "i16_item=" << to_string(i16_item);
    out << ", "
        << "i32_item=" << to_string(i32_item);
    out << ", "
        << "i64_item=" << to_string(i64_item);
    out << ", "
        << "double_item=" << to_string(double_item);
    out << ", "
        << "string_item=" << to_string(string_item);
    out << ", "
        << "list_i32_item=" << to_string(list_i32_item);
    out << ", "
        << "set_i32_item=" << to_string(set_i32_item);
    out << ", "
        << "map_i32_item=" << to_string(map_i32_item);
    out << ")";
}
}
}
} // namespace
